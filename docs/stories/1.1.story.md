# Story 1.1 – Define product with multi‑unit structure

## Status

Draft

## Story

**As a** pharmacist,
**I want** to define products with Box/Pad/Piece and conversion factors,
**so that** stock is tracked correctly across units.

[Source: docs/prd/epic-inventory.md#epic-1--product--multi-unit-model-box--pad--piece]

## Acceptance Criteria

1. I can create/edit a product with:
   - Name, code, main unit.
   - Units: Box, Pad, Piece with configurable counts (e.g. 1 box = N pads, 1 pad = M pieces).
2. System stores and uses conversion factors consistently.
3. Validation prevents zero/negative or clearly invalid conversions.

[Source: docs/prd/epic-inventory.md#epic-1--product--multi-unit-model-box--pad--piece]

## Tasks / Subtasks

- [ ] Design product and unit data model in Appwrite (AC: 1, 2)
  - [ ] Define Appwrite collection(s) for products and unit conversions, including:
    - Product `name`, `code`, `mainUnit` (e.g. box/pad/piece).
    - Conversion factors such as `boxToPad`, `padToPiece` or equivalent representation.
    - Any additional metadata that will be reused by later stories (for example, fields to be extended in Epic 4 for minimum and reorder levels).
    - Ensure the model can represent products that use only some units (for example, Box→Piece without Pad).
  - [ ] Document conversion logic assumptions (for example, all conversions are integer multiples).

  [Source: docs/brief.md#proposed-solution]

- [ ] Implement backend logic for consistent conversions (AC: 2, 3)
  - [ ] Implement a reusable conversion utility or Appwrite function that:
    - Converts quantities between Box, Pad, and Piece using stored factors.
    - Normalizes quantities into a canonical base unit (for example, pieces) for internal calculations.
  - [ ] Enforce validation rules:
    - Reject zero or negative conversion factors.
    - Reject clearly invalid relationships that would break consistency (for example, a configuration that yields zero total pieces).
  - [ ] Add basic error reporting suitable for surfacing to the UI without exposing internal technical details.

  [Source: docs/prd/epic-inventory.md#epic-1--product--multi-unit-model-box--pad--piece]

- [ ] Implement product create/edit UI (AC: 1, 3)
  - [ ] Build a form for creating and editing products including:
    - Name, code, main unit.
    - Box, Pad, Piece unit counts / conversion configuration.
  - [ ] Apply frontend validation rules consistent with backend:
    - Required fields cannot be empty.
    - Conversion counts must be positive.
  - [ ] Ensure UX aligns with the pharmacist’s need for quick, clear data entry.

  [Source: docs/brief.md#target-users]

- [ ] Prepare for normalized‑quantity usage in later stories (AC: 2)
  - [ ] Ensure the conversion logic is reusable by inventory views and stock operations (Epics 2–3 and Story 1.2).
  - [ ] Expose helper(s) or API responses that return both primary unit and equivalent pieces for consumption by UI and reporting layers.

  [Source: docs/prd/epic-inventory.md#epic-1--product--multi-unit-model-box--pad--piece]

- [ ] Testing tasks (AC: 2, 3)
  - [ ] Unit tests for conversion functions (for example, box→pad→piece, invalid configurations).
  - [ ] Integration tests covering product create/edit plus persistence of conversions in Appwrite.
  - [ ] Basic UI tests for validation rules and error messaging.

  [Source: docs/brief.md#technical-considerations]

## Dev Notes

### Previous Story Insights

- This is the first story in Epic 1; there is no previous Dev Agent Record to reference.

### Data Models

- Architecture docs referenced in `.bmad-core/core-config.yaml` (for example, `docs/architecture/...`) are not present in the repository at the time of drafting. No formal architecture specification for the product/units schema is available yet.
  [Source: .bmad-core/core-config.yaml]
- From the Project Brief, the system will use Appwrite Databases/TablesDB to store products, units, batches, movements, thresholds, and users.
  [Source: docs/brief.md#technical-considerations]
- For this story, the developer should define an Appwrite data model that can represent:
  - A product’s identity (`name`, `code`) and primary unit.
  - Conversion factors between Box, Pad, and Piece that support consistent normalization across all inventory operations.
- Capture any additional schema decisions (field names, types, constraints) in the Dev Agent Record and/or architecture docs once created.

### Assumptions & Edge Cases

- All conversion factors are treated as positive integers (no fractional units) unless future requirements explicitly change this.
- Products may use only some of the units (for example, Box→Pad→Piece without Pad); conversion logic must handle missing intermediate units predictably.
- Extremely large conversion factors that are not realistic for a pharmacy context should be rejected or treated as configuration errors.
- These assumptions should be revisited and updated once formal domain and architecture documentation is available.

### API Specifications

- There is no dedicated backend/API specification document available under `docs/architecture` yet.
  [Source: .bmad-core/core-config.yaml]
- Any API functions or endpoints added for product definitions should:
  - Use Appwrite as the BaaS layer.
    [Source: docs/brief.md#technical-considerations]
  - Align with the future architecture docs once they exist.
- Document any new endpoints, payload structures, and error shapes in the Dev Agent Record and, later, in architecture docs.

### Component Specifications

- Architecture/UI component documentation (for example, `frontend-architecture.md`, `components.md`) is not yet available under `docs/architecture`.
- For now, follow the existing React SPA stack (React, Vite, TypeScript, Tailwind CSS, React Router) and the project’s UI component library conventions when implementing the product create/edit form.
  [Source: docs/brief.md#technology-preferences]

### File Locations

- `.bmad-core/core-config.yaml` references `docs/architecture/unified-project-structure.md`, but that file and the `docs/architecture` directory do not exist yet.
  [Source: .bmad-core/core-config.yaml]
- Until a unified project‑structure document exists, follow current frontend and Appwrite functions directory conventions in this repo and document all created/modified files in the Dev Agent Record → File List.

### Testing Requirements

- There is no `testing-strategy.md` architecture document yet; testing patterns are not formally specified.
  [Source: .bmad-core/core-config.yaml]
- For this story:
  - Add unit tests around conversion logic and validation rules.
  - Add integration‑level tests for product creation/update flows touching Appwrite.
  - Ensure tests are discoverable and follow whatever baseline conventions already exist in the codebase (to be documented in future architecture/testing docs).

### Technical Constraints

- Frontend is a React SPA with Vite, TypeScript, Tailwind CSS, and React Router.
  [Source: docs/brief.md#technology-preferences]
- Backend relies on Appwrite for auth, database, functions, and storage.
  [Source: docs/brief.md#technology-preferences]
- Design solutions that are efficient for thousands of SKUs and tens of thousands of stock movements as per performance expectations.
  [Source: docs/brief.md#platform-requirements]

### Project Structure Notes

- There is a mismatch between `.bmad-core/core-config.yaml` (which expects sharded architecture docs under `docs/architecture`) and the current repository (where that directory is missing).
- Once architecture docs are added, this story’s Dev Notes and tasks should be reviewed and updated to include precise file paths, component locations, and any additional constraints from those documents.

## Testing

- **Approach**
  - Unit tests for conversion utilities and validation logic.
  - Integration tests for product creation/editing with stored conversion factors.
- **Key Scenarios**
  - Create a product with a valid Box/Pad/Piece configuration and verify stored values. (AC: 1, 2)
  - Attempt to save with zero/negative conversions (should fail validation and show a clear error). (AC: 1, 3)
  - Update conversions and ensure derived quantities remain consistent across reads. (AC: 2)
  - Ensure each key scenario is explicitly traceable to at least one Acceptance Criterion (13).
- **Success Criteria**
  - All tests associated with this story pass in CI.
  - Manual smoke test confirms that products created via the UI persist correctly and conversions behave as expected.

## Change Log

| Date       | Version | Description                        | Author |
| ---------- | ------- | ---------------------------------- | ------ |
| YYYY-MM-DD | 0.1     | Initial draft of Story 1.1        | Scrum Master |

## Dev Agent Record

### Agent Model Used

_TBD by dev agent._

### Debug Log References

_TBD by dev agent._

### Completion Notes List

_TBD by dev agent._

### File List

_TBD by dev agent._

## QA Results

_TBD by QA agent once implementation is complete._
